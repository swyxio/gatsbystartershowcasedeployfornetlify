{"data":{"markdownRemark":{"html":"<p>There are two types of plugins that work within Gatsby’s data system, “source”\nand “transformer” plugins.</p>\n<ul>\n<li><strong>Source</strong> plugins “source” data from remote or local locations into what\nGatsby calls <a href=\"/docs/node-interface/\">nodes</a>.</li>\n<li><strong>Transformer</strong> plugins “transform” data provided by source plugins into new\nnodes and/or node fields.</li>\n</ul>\n<p>For example:</p>\n<p>The <a href=\"/packages/gatsby-source-filesystem/\"><code class=\"language-text\">gatsby-source-filesystem</code></a> plugin\n“sources” data about files from the file system. It creates nodes with a type\n<code class=\"language-text\">File</code>, each File node corresponding to a file on the filesystem. On each node\nare fields like the <code class=\"language-text\">absolutePath</code>, <code class=\"language-text\">extension</code>, <code class=\"language-text\">modifiedTime</code>, etc.</p>\n<p>And importantly, each node created by the filesystem source plugin includes the\nraw content of the file and its <em>media type</em>.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Media_type\">A <strong>media type</strong></a> (also <strong>MIME type</strong>\nand <strong>content type</strong>) are an official way to identify the format of\nfiles/content that is transmitted on the internet e.g. over HTTP or through\nemail. You’re probably familiar with many media types such as\n<code class=\"language-text\">application/javascript</code>, <code class=\"language-text\">application/pdf</code>, <code class=\"language-text\">audio/mpeg</code>, <code class=\"language-text\">text/html</code>,\n<code class=\"language-text\">text/plain</code>, <code class=\"language-text\">image/jpeg</code>, etc.</p>\n<p>Each source plugin is responsible for setting the media type for the nodes they\ncreate. This way, source and transformer plugins can work together easily.</p>\n<p>This is not a required field but it’s the way for source plugins to indicate to\ntransformers that there is “raw” data that can still be further processed. It\nallows plugins to remain small and focused. Source plugins don’t have to have\nopinions on how to transform their data. They can just set the <code class=\"language-text\">mediaType</code> and\npush that responsibility to transformer plugins.</p>\n<p>For example, it’s quite common for services to allow you to add content as\nmarkdown. If you pull that markdown into Gatsby and create a new node, what\nthen? How would a user of your source plugin convert that markdown into HTML\nthey can use in their site? Luckily you don’t have to do anything. Just create a\nnode for the markdown content and set its mediaType as <code class=\"language-text\">text/markdown</code> and the\nvarious Gatsby markdown transformer plugins will see your node and transform it\ninto HTML.</p>\n<p>This loose coupling between data source and transformer plugins allow Gatsby\nsite builders to quickly assemble complex data transformation pipelines with\nlittle work on their (and your (the source plugin author)) part.</p>\n<p>What does the code look like?</p>\n<p>A source plugin is a normal NPM package. It has a package.json with optional\ndependencies as well as a <code class=\"language-text\">gatsby-node.js</code> where you implement Gatsby’s Node.js\nAPIs. Gatsby supports node versions back to Node 4 and as it’s common to want to\nuse more modern node.js and JavaScript syntax, many plugins write code in a\n<code class=\"language-text\">src</code> directory and compile the code. All plugins maintained in the Gatsby repo\nfollow this pattern.</p>\n<p>Your <code class=\"language-text\">gatsby-node.js</code> should look something like:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\">exports<span class=\"token punctuation\">.</span>sourceNodes <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> actions <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> createNode <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> actions\n  <span class=\"token comment\">// Create nodes here, generally by downloading data</span>\n  <span class=\"token comment\">// from a remote API.</span>\n  <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token constant\">REMOTE_API</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// Process data into nodes.</span>\n  data<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>datum <span class=\"token operator\">=></span> <span class=\"token function\">createNode</span><span class=\"token punctuation\">(</span><span class=\"token function\">processDatum</span><span class=\"token punctuation\">(</span>datum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// We're done, return.</span>\n  <span class=\"token keyword\">return</span>\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<p>Peruse the <a href=\"/docs/node-apis/#sourceNodes\"><code class=\"language-text\">sourceNodes</code></a> and\n<a href=\"/docs/bound-action-creators/#createNode\"><code class=\"language-text\">createNode</code></a> docs for detailed\ndocumentation on implementing those APIs.</p>\n<p>But at a high-level, these are the jobs of a source plugin:</p>\n<ul>\n<li>Ensure local data is synced with its source and 100% accurate. If your source\nallows you to add an <code class=\"language-text\">updatedSince</code> query (or something similar) you can store\nthe last time you fetched data using\n<a href=\"/docs/bound-action-creators/#setPluginStatus\"><code class=\"language-text\">setPluginStatus</code></a>.</li>\n<li>Create nodes with accurate media types, human meaningful types, and accurate\ncontentDigests.</li>\n<li>“Link” nodes types you create as appropriate (see\n<a href=\"/docs/api-specification/\"><em>Node Link</em></a> in the API specification concepts\nsection.</li>\n<li>Return either a promise or use the callback (3rd parameter) to report back to\nGatsby when you’re done sourcing nodes. Otherwise either Gatsby will continue\non before you’re done sourcing or hang while waiting for you to indicate\nyou’re finished.</li>\n</ul>\n<p><a href=\"https://github.com/angeloashmore/gatsby-node-helpers\"><code class=\"language-text\">gatsby-node-helpers</code></a>,\na community-made NPM package, can help when writing source plugins. This\npackage provides a set of helper functions to generate Node objects with the\nrequired fields. This includes automatically generating fields like node IDs\nand the <code class=\"language-text\">contentDigest</code> MD5 hash, keeping your code focused on data gathering,\nnot boilerplate.</p>","excerpt":"There are two types of plugins that work within Gatsby’s data system, “source”\nand “transformer” plugins. Source  plugins “source” data from…","timeToRead":3,"fields":{"slug":"/docs/create-source-plugin/","anchor":"create-source-plugin"},"frontmatter":{"title":"Create a Source Plugin"},"parent":{"__typename":"File","relativePath":"docs/create-source-plugin.md"}}},"pageContext":{"slug":"/docs/create-source-plugin/"}}